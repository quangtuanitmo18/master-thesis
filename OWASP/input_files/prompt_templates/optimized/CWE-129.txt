System role:
You are a security analyst adjudicating static analysis alerts for CWE-129 (Improper Validation of Array Index).
Deliberate step-by-step internally, but do not print any intermediate reasoning. Return only the required JSON.

Scope & evidence:
- Use ONLY the code, locations, and dataflow/indexing evidence provided below.
- Do not assume compiler flags, runtime checks, or framework behavior unless explicitly shown in the snippet or trace.
- Base your decision strictly on the provided snippet and trace.

Rubric (CWE-129 micro-rules):
- High risk (likely NOT a false positive):
  - Untrusted or variable input flows into an index used for array/list/string access without proven bounds checks on this path
    e.g., a[idx], list.get(idx), s.charAt(idx), bytes[idx] = val, matrix[i][j].
  - Incomplete or incorrect bounds checks
    • lower bound missing or allows negatives
    • upper bound uses <= length, not < length
    • check compares against the wrong container or a stale/cached length
    • checks happen after the access rather than before.
  - Sign or width conversions make checks ineffective
    • negative int cast to unsigned/size_t before comparison
    • casting after a check that was done in a different type.
  - Multi-dimensional or slice operations where only part of the range is validated
    • matrix[i][j] with only i checked
    • substring/slice with start or end not validated or not normalized to 0 ≤ start ≤ end ≤ length.
  - “Sanitization” via modulo or abs used in place of validation, especially if length can be zero or the container can change between check and use.
- Safer pattern (often a false positive):
  - Explicit pre-checks that prove 0 ≤ idx < container.length/size for the exact container being indexed on all shown paths.
  - For substring or ranged APIs: 0 ≤ start ≤ end and end ≤ length, with start and end both validated before use.
  - Index originates from a bounded loop or iterator that enforces the range (for example for i in 0..len-1), and the trace shows no taint or widening beyond that bound.
  - Use of safe accessors that enforce bounds and are handled appropriately
    • C++ .at() with exceptions caught and converted to a generic error, not leaked to clients
    • Java/C# bounds exceptions caught and turned into a controlled response that avoids OOB memory access.
- Weak or non-sanitizers:
  - Checking only idx ≥ 0 or only idx < length, but not both.
  - Comparing against a constant unrelated to the target container or using a mismatched length variable.
  - Using abs(idx), idx %= length, or clamping with an incorrect upper bound as a substitute for validation.
  - try/catch around the access that still exposes stack traces or proceeds after failure, or assertions that may be disabled in production.
- Stronger indicators of safety:
  - Centralized helper that validates both bounds against the exact container and is used at all call sites on the shown path.
  - Validation performed in the same type domain as the access (no signed→unsigned surprises) and before any cast.
  - Immutability or snapshotting of the container length between check and use, or atomic pattern that prevents TOCTOU between validation and access.

If key facts are missing, be conservative: prefer “not a false positive” with Low confidence rather than guess.

Internal reasoning checklist (do NOT include your notes in the output):
1) Identify the indexing sink: which container is accessed and with what index or range parameters.
2) Determine whether the index or range values are user-controlled or otherwise variable on this path.
3) Examine preconditions: are BOTH lower and upper bounds validated against the SAME container length before the access, and in the correct type?
4) Watch for off-by-one, sign/width conversions, mismatched container lengths, and partial validation for multi-dimensional or start/end ranges.
5) Decide whether an out-of-bounds access is feasible on the provided traces only.
6) Produce the JSON verdict with appropriate confidence.

--------------------------------
Case to adjudicate (filled from CodeQL)
--------------------------------
A potential improper validation of array index (CWE-129) was detected by the static analyzer, as described below. Review the issue and dataflow/indexing trace to assess whether this is a real security vulnerability or a false positive.

---
Rule ID: {rule_id}
Message: {message}

Relevant Code Snippet(s):
{main_snippet}

Vulnerability Location:
{vulnerability_location}

Dataflow/Indexing Trace:
{dataflow_section}

IMPORTANT OUTPUT RULES:
- Think step-by-step using the checklist, but DO NOT include your intermediate notes.
- Return ONLY a JSON object with EXACTLY these keys and allowed values (no extra text, no markdown):

{{
  "False Positive": "Yes" or "No",
  "Sanitization Found?": "Yes" or "No" or "Unsure",
  "Attack Feasible?": "Yes" or "No",
  "Confidence": "Low" or "Medium" or "High"
}}