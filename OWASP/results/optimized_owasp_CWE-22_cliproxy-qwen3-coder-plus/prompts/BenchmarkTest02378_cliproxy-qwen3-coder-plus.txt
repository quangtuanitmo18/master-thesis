System role:
You are a security analyst adjudicating static analysis alerts for CWE-022 (Path Traversal).
Deliberate step-by-step internally, but do not print any intermediate reasoning. Return only the required JSON.

Scope & evidence:
- Use ONLY the code, locations, and dataflow provided below.
- Do not assume behavior of code that is not shown (e.g., filesystem/proxy configs).
- Base your decision strictly on the provided snippet and trace.

Rubric (CWE-022 micro-rules):
- Path traversal occurs when untrusted input influences filesystem paths so an attacker can access files outside an intended directory or target unexpected locations.
- High risk (likely NOT a false positive):
  - Concatenating user input into paths for read/write/delete/list/extract without robust normalization and restriction.
  - Accepting absolute paths or traversal sequences: "../", "..\", leading "/", drive letters like "C:\", UNC paths "\\", tilde "~/" or env-expansion patterns.
  - Archive extraction using entry names directly (Zip Slip) to write files relative to a base directory.
  - TOCTOU/symlink issues: checks (exists/isDirectory) before open without canonical path verification; following symlinks unintentionally.
- Safer patterns (often a false positive):
  - Resolve against a fixed base directory and **normalize + canonicalize**, then enforce prefix:
    - e.g., `Path target = base.resolve(user).normalize();` then ensure `target.startsWith(base)` (or canonical path prefix check).
  - Reject absolute paths and any traversal after normalization; decode URL-encoded input **before** validation.
  - Use strict allowlists or ID→filename mapping (no free-form paths); fixed filenames; APIs that avoid filesystem writes entirely.
  - Symlink-safe operations (e.g., `toRealPath(LinkOption.NOFOLLOW_LINKS)` with prefix check) and writing with secure temp dirs.
- Not sanitizers / insufficient alone:
  - Simple string replace of "../" or only checking `!path.contains("..")`; extension checks only; regex that misses backslashes or double-encoding; client-side checks; `File.exists()`/`isDirectory()` without canonical prefix enforcement.
- Context notes:
  - Validate **after** decoding (URL/percent, UTF-8 normalization) and **before** use.
  - For Windows, consider both separators and drive/UNC paths; for archives, validate each entry path separately.
  - Authorization by path naming alone is fragile; prefer server-side mapping.

Interpretation of fields for this CWE:
- “Sanitization Found?” = robust normalization/canonicalization with base-path prefix enforcement, strict allowlists, and symlink-safe handling evident in the snippet.
- “Attack Feasible?” = given the shown code, could an attacker reach outside the intended directory or target unintended files (including via archives/symlinks)?

Internal reasoning checklist (do NOT include your notes in the output):
1) Identify the untrusted source and how it forms the filesystem path (concat, resolve, archive entry).
2) Determine whether normalization/canonicalization and a base-path prefix check are applied **after decoding** and **before** use.
3) Check rejection of absolute paths, traversal sequences, backslashes, drive/UNC paths; consider double-encoding.
4) Consider symlink/TOCTOU risks and archive extraction (Zip Slip) patterns.
5) Decide if traversal is feasible; set confidence based on visible evidence.
6) Produce the JSON verdict with appropriate confidence.

--------------------------------
Case to adjudicate (filled from CodeQL)
--------------------------------
A potential path traversal vulnerability (CWE-022) was detected by the static analyzer, as described below. Review the issue and dataflow to assess whether this is a real security vulnerability or a false positive.

---
Rule ID: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
Message: Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path.

Vulnerable Code Snippet:
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class BenchmarkTest02378 extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        org.owasp.benchmark.helpers.SeparateClassRequest scr =
                new org.owasp.benchmark.helpers.SeparateClassRequest(request);
        String param = scr.getTheParameter("BenchmarkTest02378");
        if (param == null) param = "";

        String bar = doSomething(request, param);

        // FILE URIs are tricky because they are different between Mac and Windows because of lack
        // of standardization.
        // Mac requires an extra slash for some reason.
        String startURIslashes = "";
        if (System.getProperty("os.name").indexOf("Windows") != -1)
            if (System.getProperty("os.name").indexOf("Windows") != -1) startURIslashes = "/";
            else startURIslashes = "//";

        try {
            java.net.URI fileURI =
                    new java.net.URI(
                            "file:"
                                    + startURIslashes
                                    + org.owasp.benchmark.helpers.Utils.TESTFILES_DIR
                                            .replace('\\', '/')
                                            .replace(' ', '_')
                                    + bar);
            java.io.File fileTarget = new java.io.File(fileURI);
            response.getWriter()
                    .println(
                            "Access to file: '"
                                    + org.owasp
                                            .esapi
                                            .ESAPI
                                            .encoder()
                                            .encodeForHTML(fileTarget.toString())
                                    + "' created.");
            if (fileTarget.exists()) {
                response.getWriter().println(" And file already exists.");
            } else {
                response.getWriter().println(" But file doesn't exist yet.");
            }
        } catch (java.net.URISyntaxException e) {
            throw new ServletException(e);
        }
    } // end doPost

    private static String doSomething(HttpServletRequest request, String param)
            throws ServletException, IOException {

        org.owasp.benchmark.helpers.ThingInterface thing =
                org.owasp.benchmark.helpers.ThingFactory.createThing();
        String bar = thing.doSomething(param);

        return bar;
    }
}

Vulnerability Location:
"fileTarget = new java.io.File(fileURI);" in the following line of code (line 67) has been detected by the static analyzer as the vulnerability location:

            java.io.File [[[fileTarget = new java.io.File(fileURI)]]];

Dataflow Trace:
[1] SOURCE:
doPost([[[request,]]] response);
 // [DATAFLOW STEP]

Message: Source: 'request' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest02378.java:35'

[2] SINK:
java.io.File [[[fileTarget = new java.io.File(fileURI);]]]
 // [DATAFLOW STEP]

Message: Sink: 'java.io.File fileTarget = new java.io.File(fileURI);' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest02378.java:67'

IMPORTANT OUTPUT RULES:
- Think step-by-step using the checklist, but DO NOT include your intermediate notes.
- Return ONLY a JSON object with EXACTLY these keys and allowed values (no extra text, no markdown):

{
  "False Positive": "Yes" or "No",
  "Sanitization Found?": "Yes" or "No" or "Unsure",
  "Attack Feasible?": "Yes" or "No",
  "Confidence": "Low" or "Medium" or "High"
}