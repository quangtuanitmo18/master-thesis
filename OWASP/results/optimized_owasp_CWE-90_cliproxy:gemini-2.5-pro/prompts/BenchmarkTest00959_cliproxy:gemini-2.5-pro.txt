System role:
You are a security analyst adjudicating static analysis alerts for CWE-090 (LDAP Injection).
Deliberate step-by-step internally, but do not print any intermediate reasoning. Return only the required JSON.

Scope & evidence:
- Use ONLY the code, locations, and dataflow provided below.
- Do not assume behavior of code that is not shown (e.g., sanitizer implementations, LDAP server config).
- Base your decision strictly on the provided snippet and trace.

Rubric (CWE-090 micro-rules):
- LDAP injection occurs when untrusted input is inserted into LDAP filters or Distinguished Names (DNs) without proper, context-specific escaping/validation.
- High risk (likely NOT a false positive):
  - Building filter strings via concatenation, e.g., "(&(uid=" + user + ")(objectClass=person))".
  - User-controlled fragments that can close/open filter groups or add wildcards/operators: ')', '(', '*', '&', '|', '!' or backslash escape injection.
  - Constructing DNs from untrusted data without DN-aware escaping (e.g., "cn=" + name + ",ou=people,dc=...").
- Safer patterns (often a false positive):
  - Proper, context-appropriate escaping:
    - Filter context (RFC 4515): escaping at least `* ( ) \` and NUL in untrusted values before insertion.
    - DN context (RFC 4514): using DN-safe builders (e.g., LdapName/Rdn in Java) or APIs that escape special DN characters and handle leading/trailing spaces and leading '#'.
  - APIs or libraries that parameterize/escape filter values automatically (e.g., Spring LDAP’s LdapQueryBuilder with arguments; safe DN builders using Rdn.add()).
  - Strict allowlists mapping user input to a bounded set of known attribute values or identifiers.
- Not sanitizers / insufficient alone:
  - Length checks; blacklists of a few characters; HTML/URL encoding; generic regex without explicit coverage of LDAP metacharacters; naive replace() escaping.
- Context notes:
  - Filter vs DN contexts require different escaping. Escaping for one is not necessarily safe for the other.
  - Wildcard control (`*`) in substring filters must be treated carefully; presence of unescaped '*' from user input is risky.
  - Attribute names (identifiers) cannot be “parameterized”; if user controls attribute names or operators, require strict allowlist.
- If key facts are missing (unknown escaping, incomplete path), be conservative: prefer “not a false positive” with Low confidence rather than guess.

Internal reasoning checklist (do NOT include your notes in the output):
1) Identify user-controlled sources and confirm they reach an LDAP sink (e.g., DirContext.search, lookup/bind with constructed DN).
2) Determine the context of insertion: filter string vs DN vs attribute name/operator.
3) Check for appropriate escaping/validation for that context (filter-escape vs DN-safe construction; allowlists for identifiers).
4) Verify whether user input can alter filter logic (inject operators, wildcards, parentheses) or DN structure.
5) Decide if injection is feasible; set confidence based on visibility and certainty.
6) Produce the JSON verdict with appropriate confidence.

--------------------------------
Case to adjudicate (filled from CodeQL)
--------------------------------
A potential LDAP injection vulnerability (CWE-090) was detected by the static analyzer, as described below. Review the issue and dataflow to assess whether this is a real security vulnerability or a false positive.

---
Rule ID: java.lang.security.audit.tainted-ldapi-from-http-request.tainted-ldapi-from-http-request
Message: Detected input from a HTTPServletRequest going into an LDAP query. This could lead to LDAP injection if the input is not properly sanitized, which could result in attackers modifying objects in the LDAP tree structure. Ensure data passed to an LDAP query is not controllable or properly sanitize the data.

Vulnerable Code Snippet:
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class BenchmarkTest00959 extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        javax.servlet.http.Cookie userCookie =
                new javax.servlet.http.Cookie("BenchmarkTest00959", "Ms+Bar");
        userCookie.setMaxAge(60 * 3); // Store cookie for 3 minutes
        userCookie.setSecure(true);
        userCookie.setPath(request.getRequestURI());
        userCookie.setDomain(new java.net.URL(request.getRequestURL().toString()).getHost());
        response.addCookie(userCookie);
        javax.servlet.RequestDispatcher rd =
                request.getRequestDispatcher("/ldapi-00/BenchmarkTest00959.html");
        rd.include(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        javax.servlet.http.Cookie[] theCookies = request.getCookies();

        String param = "noCookieValueSupplied";
        if (theCookies != null) {
            for (javax.servlet.http.Cookie theCookie : theCookies) {
                if (theCookie.getName().equals("BenchmarkTest00959")) {
                    param = java.net.URLDecoder.decode(theCookie.getValue(), "UTF-8");
                    break;
                }
            }
        }

        String bar = new Test().doSomething(request, param);

        org.owasp.benchmark.helpers.LDAPManager ads = new org.owasp.benchmark.helpers.LDAPManager();
        try {
            response.setContentType("text/html;charset=UTF-8");
            String base = "ou=users,ou=system";
            javax.naming.directory.SearchControls sc = new javax.naming.directory.SearchControls();
            sc.setSearchScope(javax.naming.directory.SearchControls.SUBTREE_SCOPE);
            String filter = "(&(objectclass=person))(|(uid=" + bar + ")(street={0}))";
            Object[] filters = new Object[] {"The streetz 4 Ms bar"};

            javax.naming.directory.DirContext ctx = ads.getDirContext();
            javax.naming.directory.InitialDirContext idc =
                    (javax.naming.directory.InitialDirContext) ctx;
            boolean found = false;
            javax.naming.NamingEnumeration<javax.naming.directory.SearchResult> results =
                    idc.search(base, filter, filters, sc);
            while (results.hasMore()) {
                javax.naming.directory.SearchResult sr =
                        (javax.naming.directory.SearchResult) results.next();
                javax.naming.directory.Attributes attrs = sr.getAttributes();

                javax.naming.directory.Attribute attr = attrs.get("uid");
                javax.naming.directory.Attribute attr2 = attrs.get("street");
                if (attr != null) {
                    response.getWriter()
                            .println(
                                    "LDAP query results:<br>"
                                            + "Record found with name "
                                            + attr.get()
                                            + "<br>"
                                            + "Address: "
                                            + attr2.get()
                                            + "<br>");
                    // System.out.println("record found " + attr.get());
                    found = true;
                }
            }
            if (!found) {
                response.getWriter()
                        .println(
                                "LDAP query results: nothing found for query: "
                                        + org.owasp.esapi.ESAPI.encoder().encodeForHTML(filter));
            }
        } catch (javax.naming.NamingException e) {
            throw new ServletException(e);
        } finally {
            try {
                ads.closeDirContext();
            } catch (Exception e) {
                throw new ServletException(e);
            }
        }
    } // end doPost

    private class Test {

        public String doSomething(HttpServletRequest request, String param)
                throws ServletException, IOException {

            String bar;

            // Simple if statement that assigns param to bar on true condition
            int num = 196;
            if ((500 / 42) + num > 200) bar = param;
            else bar = "This should never happen";

            return bar;
        }
    } // end innerclass Test
} // end DataflowThruInnerClass

Vulnerability Location:
"idc.search(base, filter, filters, sc);" in the following line of code (line 81) has been detected by the static analyzer as the vulnerability location:

                    [[[idc.search(base, filter, filters, sc)]]];

Dataflow Trace:
[1] SOURCE:
javax.servlet.http.Cookie[] theCookies = [[[request.]]]getCookies();
 // [DATAFLOW STEP]

Message: Source: 'request' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:53'

[2] STEP:
javax.servlet.http.Cookie[] [[[theCookies ]]]= request.getCookies();
 // [DATAFLOW STEP]

Message: Propagator : 'theCookies' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:53'

[3] STEP:
for (javax.servlet.http.Cookie [[[theCookie ]]]: theCookies) {
 // [DATAFLOW STEP]

Message: Propagator : 'theCookie' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:57'

[4] STEP:
for (javax.servlet.http.Cookie [[[theCookie ]]]: theCookies) {
 // [DATAFLOW STEP]

Message: Propagator : 'theCookie' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:57'

[5] STEP:
[[[param ]]]= java.net.URLDecoder.decode(theCookie.getValue(), "UTF-8");
 // [DATAFLOW STEP]

Message: Propagator : 'param' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:59'

[6] STEP:
String [[[bar ]]]= new Test().doSomething(request, param);
 // [DATAFLOW STEP]

Message: Propagator : 'bar' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:65'

[7] STEP:
String [[[filter ]]]= "(&(objectclass=person))(|(uid=" + bar + ")(street={0}))";
 // [DATAFLOW STEP]

Message: Propagator : 'filter' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:73'

[8] SINK:
[[[idc.search(base, filter, filters, sc);]]]
 // [DATAFLOW STEP]

Message: Sink: 'idc.search(base, filter, filters, sc);' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest00959.java:81'

IMPORTANT OUTPUT RULES:
- Think step-by-step using the checklist, but DO NOT include your intermediate notes.
- Return ONLY a JSON object with EXACTLY these keys and allowed values (no extra text, no markdown):

{
  "False Positive": "Yes" or "No",
  "Sanitization Found?": "Yes" or "No" or "Unsure",
  "Attack Feasible?": "Yes" or "No",
  "Confidence": "Low" or "Medium" or "High"
}