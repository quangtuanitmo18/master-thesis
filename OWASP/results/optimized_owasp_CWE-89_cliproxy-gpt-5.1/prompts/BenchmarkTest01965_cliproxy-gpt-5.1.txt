System role:
You are a security analyst adjudicating static analysis alerts for CWE-089 (SQL Injection).
Deliberate step-by-step internally, but do not print any intermediate reasoning. Return only the required JSON.

Scope & evidence:
- Use ONLY the code, locations, and dataflow provided below.
- Do not assume behavior of code that is not shown (e.g., sanitizer implementations, DB settings).
- Base your decision strictly on the provided snippet and trace.

Rubric (CWE-089 micro-rules):
- SQLi occurs when untrusted input influences SQL syntax (strings, identifiers, operators) in a query executed by the database.
- High risk (likely NOT a false positive):
  - Building queries via string concatenation or format/printf with untrusted data.
  - Using Statement/EntityManager.createNativeQuery with concatenated parameters.
  - Dynamic construction of WHERE/ORDER BY/LIMIT, table/column names, or operators from untrusted data.
  - Executing shell/database CLI with query strings assembled from untrusted input.
- Safer patterns (often a false positive):
  - Prepared/parameterized statements (e.g., PreparedStatement with ? placeholders; named parameters) where ALL untrusted values are bound as parameters.
  - ORM/query builders with auto-parameterization (and no string interpolation or “raw SQL” escape hatches).
  - Strict allowlists that map user input to a bounded set of constants (e.g., enum-to-clause mapping).
- Not sanitizers / insufficient alone:
  - Length checks; blacklists of a few characters; naive escaping or replace() (e.g., removing quotes); HTML/URL encoding for SQL context; type-casting without parameterization.
  - Escaping used incorrectly (e.g., manual quoting with unverified DB-specific rules).
- Context notes:
  - LIKE queries need parameterization; escaping % and _ is required if user controls pattern.
  - Identifier injection: if user controls table/column/order-by name, require allowlist mapping (parameters do not bind identifiers).
  - Stored procedures are only safe if parameters are used and dynamic SQL inside the proc is not built from untrusted input.
- If key facts are missing (unknown binding, incomplete path), be conservative: prefer “not a false positive” with Low confidence rather than guess.

Internal reasoning checklist (do NOT include your notes in the output):
1) Identify user-controlled sources and confirm they reach a SQL execution sink.
2) Determine how the query is formed: concatenation/format vs parameter placeholders.
3) Verify whether EVERY untrusted value is bound via parameters (not just some).
4) Check for context-specific risks (identifiers, ORDER BY/LIMIT, LIKE patterns, dynamic fragments).
5) Identify any validation/sanitization and assess whether it actually prevents syntax injection (strict allowlist vs weak filters).
6) Decide if injection is feasible; set confidence based on code visibility and certainty.
7) Produce the JSON verdict with appropriate confidence.

--------------------------------
Case to adjudicate (filled from CodeQL)
--------------------------------
A potential SQL injection vulnerability (CWE-089) was detected by the static analyzer, as described below. Review the issue and dataflow to assess whether this is a real security vulnerability or a false positive.

---
Rule ID: java.lang.security.audit.sqli.tainted-sql-from-http-request.tainted-sql-from-http-request
Message: Detected input from a HTTPServletRequest going into a SQL sink or statement. This could lead to SQL injection if variables in the SQL statement are not properly sanitized. Use parameterized SQL queries or properly sanitize user input instead.

Vulnerable Code Snippet:
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class BenchmarkTest01965 extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        String param = "";
        if (request.getHeader("BenchmarkTest01965") != null) {
            param = request.getHeader("BenchmarkTest01965");
        }

        // URL Decode the header value since req.getHeader() doesn't. Unlike req.getParameter().
        param = java.net.URLDecoder.decode(param, "UTF-8");

        String bar = doSomething(request, param);

        String sql = "SELECT userid from USERS where USERNAME='foo' and PASSWORD='" + bar + "'";
        try {
            // Long results =
            // org.owasp.benchmark.helpers.DatabaseHelper.JDBCtemplate.queryForLong(sql);
            Long results =
                    org.owasp.benchmark.helpers.DatabaseHelper.JDBCtemplate.queryForObject(
                            sql, Long.class);
            response.getWriter().println("Your results are: " + String.valueOf(results));
        } catch (org.springframework.dao.EmptyResultDataAccessException e) {
            response.getWriter()
                    .println(
                            "No results returned for query: "
                                    + org.owasp.esapi.ESAPI.encoder().encodeForHTML(sql));
        } catch (org.springframework.dao.DataAccessException e) {
            if (org.owasp.benchmark.helpers.DatabaseHelper.hideSQLErrors) {
                response.getWriter().println("Error processing request.");
            } else throw new ServletException(e);
        }
    } // end doPost

    private static String doSomething(HttpServletRequest request, String param)
            throws ServletException, IOException {

        String bar;

        // Simple ? condition that assigns constant to bar on true condition
        int num = 106;

        bar = (7 * 18) + num > 200 ? "This_should_always_happen" : param;

        return bar;
    }
}

Vulnerability Location:
"Long results =" in the following line of code (line 57) has been detected by the static analyzer as the vulnerability location:

            Long results =

Dataflow Trace:
[1] SOURCE:
param = [[[request.getHeader("BenchmarkTest01965");]]]
 // [DATAFLOW STEP]

Message: Source: 'request.getHeader("BenchmarkTest01965")' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:45'

[2] STEP:
[[[param ]]]= request.getHeader("BenchmarkTest01965");
 // [DATAFLOW STEP]

Message: Propagator : 'param' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:45'

[3] STEP:
String bar = [[[doSomething(]]]request, param);
 // [DATAFLOW STEP]

Message: Propagator : 'doSomething' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:51'

[4] STEP:
private static String doSomething(HttpServletRequest request, String [[[param)]]]
 // [DATAFLOW STEP]

Message: Propagator : 'param' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:73'

[5] STEP:
[[[bar ]]]= (7 * 18) + num > 200 ? "This_should_always_happen" : param;
 // [DATAFLOW STEP]

Message: Propagator : 'bar' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:81'

[6] STEP:
String [[[bar ]]]= doSomething(request, param);
 // [DATAFLOW STEP]

Message: Propagator : 'bar' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:51'

[7] STEP:
String [[[sql ]]]= "SELECT userid from USERS where USERNAME='foo' and PASSWORD='" + bar + "'";
 // [DATAFLOW STEP]

Message: Propagator : 'sql' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:53'

[8] SINK:
Long results =
                    org.owasp.benchmark.helpers.DatabaseHelper.JDBCtemplate.queryForObject(
                            sql, Long.class);

Message: Sink: 'Long results =
                    org.owasp.benchmark.helpers.DatabaseHelper.JDBCtemplate.queryForObject(
                            sql, Long.class);' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01965.java:57'

IMPORTANT OUTPUT RULES:
- Think step-by-step using the checklist, but DO NOT include your intermediate notes.
- Return ONLY a JSON object with EXACTLY these keys and allowed values (no extra text, no markdown):

{
  "False Positive": "Yes" or "No",
  "Sanitization Found?": "Yes" or "No" or "Unsure",
  "Attack Feasible?": "Yes" or "No",
  "Confidence": "Low" or "Medium" or "High"
}