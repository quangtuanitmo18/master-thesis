System role:
You are a security analyst adjudicating static analysis alerts for CWE-022 (Path Traversal).
Deliberate step-by-step internally, but do not print any intermediate reasoning. Return only the required JSON.

Scope & evidence:
- Use ONLY the code, locations, and dataflow provided below.
- Do not assume behavior of code that is not shown (e.g., filesystem/proxy configs).
- Base your decision strictly on the provided snippet and trace.

Rubric (CWE-022 micro-rules):
- Path traversal occurs when untrusted input influences filesystem paths so an attacker can access files outside an intended directory or target unexpected locations.
- High risk (likely NOT a false positive):
  - Concatenating user input into paths for read/write/delete/list/extract without robust normalization and restriction.
  - Accepting absolute paths or traversal sequences: "../", "..\", leading "/", drive letters like "C:\", UNC paths "\\", tilde "~/" or env-expansion patterns.
  - Archive extraction using entry names directly (Zip Slip) to write files relative to a base directory.
  - TOCTOU/symlink issues: checks (exists/isDirectory) before open without canonical path verification; following symlinks unintentionally.
- Safer patterns (often a false positive):
  - Resolve against a fixed base directory and **normalize + canonicalize**, then enforce prefix:
    - e.g., `Path target = base.resolve(user).normalize();` then ensure `target.startsWith(base)` (or canonical path prefix check).
  - Reject absolute paths and any traversal after normalization; decode URL-encoded input **before** validation.
  - Use strict allowlists or ID→filename mapping (no free-form paths); fixed filenames; APIs that avoid filesystem writes entirely.
  - Symlink-safe operations (e.g., `toRealPath(LinkOption.NOFOLLOW_LINKS)` with prefix check) and writing with secure temp dirs.
- Not sanitizers / insufficient alone:
  - Simple string replace of "../" or only checking `!path.contains("..")`; extension checks only; regex that misses backslashes or double-encoding; client-side checks; `File.exists()`/`isDirectory()` without canonical prefix enforcement.
- Context notes:
  - Validate **after** decoding (URL/percent, UTF-8 normalization) and **before** use.
  - For Windows, consider both separators and drive/UNC paths; for archives, validate each entry path separately.
  - Authorization by path naming alone is fragile; prefer server-side mapping.

Interpretation of fields for this CWE:
- “Sanitization Found?” = robust normalization/canonicalization with base-path prefix enforcement, strict allowlists, and symlink-safe handling evident in the snippet.
- “Attack Feasible?” = given the shown code, could an attacker reach outside the intended directory or target unintended files (including via archives/symlinks)?

Internal reasoning checklist (do NOT include your notes in the output):
1) Identify the untrusted source and how it forms the filesystem path (concat, resolve, archive entry).
2) Determine whether normalization/canonicalization and a base-path prefix check are applied **after decoding** and **before** use.
3) Check rejection of absolute paths, traversal sequences, backslashes, drive/UNC paths; consider double-encoding.
4) Consider symlink/TOCTOU risks and archive extraction (Zip Slip) patterns.
5) Decide if traversal is feasible; set confidence based on visible evidence.
6) Produce the JSON verdict with appropriate confidence.

--------------------------------
Case to adjudicate (filled from CodeQL)
--------------------------------
A potential path traversal vulnerability (CWE-022) was detected by the static analyzer, as described below. Review the issue and dataflow to assess whether this is a real security vulnerability or a false positive.

---
Rule ID: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
Message: Detected a potential path traversal. A malicious actor could control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are sanitized. You may also consider using a utility method such as org.apache.commons.io.FilenameUtils.getName(...) to only retrieve the file name from the path.

Vulnerable Code Snippet:
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
public class BenchmarkTest01159 extends HttpServlet {

    private static final long serialVersionUID = 1L;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        doPost(request, response);
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        String param = "";
        java.util.Enumeration<String> headers = request.getHeaders("BenchmarkTest01159");

        if (headers != null && headers.hasMoreElements()) {
            param = headers.nextElement(); // just grab first element
        }

        // URL Decode the header value since req.getHeaders() doesn't. Unlike req.getParameters().
        param = java.net.URLDecoder.decode(param, "UTF-8");

        String bar = new Test().doSomething(request, param);

        String fileName = null;
        java.io.FileInputStream fis = null;

        try {
            fileName = org.owasp.benchmark.helpers.Utils.TESTFILES_DIR + bar;
            fis = new java.io.FileInputStream(fileName);
            byte[] b = new byte[1000];
            int size = fis.read(b);
            response.getWriter()
                    .println(
                            "The beginning of file: '"
                                    + org.owasp.esapi.ESAPI.encoder().encodeForHTML(fileName)
                                    + "' is:\n\n");
            response.getWriter()
                    .println(org.owasp.esapi.ESAPI.encoder().encodeForHTML(new String(b, 0, size)));
        } catch (Exception e) {
            System.out.println("Couldn't open FileInputStream on file: '" + fileName + "'");
            //			System.out.println("File exception caught and swallowed: " + e.getMessage());
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                    fis = null;
                } catch (Exception e) {
                    // we tried...
                }
            }
        }
    } // end doPost

    private class Test {

        public String doSomething(HttpServletRequest request, String param)
                throws ServletException, IOException {

            // Chain a bunch of propagators in sequence
            String a54259 = param; // assign
            StringBuilder b54259 = new StringBuilder(a54259); // stick in stringbuilder
            b54259.append(" SafeStuff"); // append some safe content
            b54259.replace(
                    b54259.length() - "Chars".length(),
                    b54259.length(),
                    "Chars"); // replace some of the end content
            java.util.HashMap<String, Object> map54259 = new java.util.HashMap<String, Object>();
            map54259.put("key54259", b54259.toString()); // put in a collection
            String c54259 = (String) map54259.get("key54259"); // get it back out
            String d54259 = c54259.substring(0, c54259.length() - 1); // extract most of it
            String e54259 =
                    new String(
                            org.apache.commons.codec.binary.Base64.decodeBase64(
                                    org.apache.commons.codec.binary.Base64.encodeBase64(
                                            d54259.getBytes()))); // B64 encode and decode it
            String f54259 = e54259.split(" ")[0]; // split it on a space
            org.owasp.benchmark.helpers.ThingInterface thing =
                    org.owasp.benchmark.helpers.ThingFactory.createThing();
            String g54259 = "barbarians_at_the_gate"; // This is static so this whole flow is 'safe'
            String bar = thing.doSomething(g54259); // reflection

            return bar;
        }
    } // end innerclass Test
} // end DataflowThruInnerClass

Vulnerability Location:
"new java.io.FileInputStream(fileName);" in the following line of code (line 60) has been detected by the static analyzer as the vulnerability location:

            fis = [[[new java.io.FileInputStream(fileName)]]];

Dataflow Trace:
[1] SOURCE:
doPost([[[request,]]] response);
 // [DATAFLOW STEP]

Message: Source: 'request' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01159.java:35'

[2] SINK:
fis = [[[new java.io.FileInputStream(fileName);]]]
 // [DATAFLOW STEP]

Message: Sink: 'fis = new java.io.FileInputStream(fileName);' @ 'src\main\java\org\owasp\benchmark\testcode\BenchmarkTest01159.java:60'

IMPORTANT OUTPUT RULES:
- Think step-by-step using the checklist, but DO NOT include your intermediate notes.
- Return ONLY a JSON object with EXACTLY these keys and allowed values (no extra text, no markdown):

{
  "False Positive": "Yes" or "No",
  "Sanitization Found?": "Yes" or "No" or "Unsure",
  "Attack Feasible?": "Yes" or "No",
  "Confidence": "Low" or "Medium" or "High"
}